"use strict";(self.webpackChunkkraken_ci_website=self.webpackChunkkraken_ci_website||[]).push([[322],{2096:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=n(4848),s=n(8453);n(4074);const r={slug:"autoscaling-with-azure-and-aws-ecs",title:"Autoscaling with Azure and AWS ECS",author:"Michal Nowikowski",author_title:"Kraken Founder. I\u2019m software engineer focused on full-stack programming and improving software processes.",author_url:"https://www.linkedin.com/in/godfryd",author_image_url:"https://avatars1.githubusercontent.com/u/176567?s=460&u=4ade22771af9569be24b20278d24ef60da6eb0bb&v=4",tags:["kraken","cloud"]},i=void 0,o={permalink:"/blog/autoscaling-with-azure-and-aws-ecs",editUrl:"https://github.com/kraken-ci/website/edit/master/blog/blog/2021-10-24-autoscaling-with-azure-and-aws-ecs.mdx",source:"@site/blog/2021-10-24-autoscaling-with-azure-and-aws-ecs.mdx",title:"Autoscaling with Azure and AWS ECS",description:"The latest release 0.748 release",date:"2021-10-24T00:00:00.000Z",tags:[{label:"kraken",permalink:"/blog/tags/kraken"},{label:"cloud",permalink:"/blog/tags/cloud"}],readingTime:.775,hasTruncateMarker:!0,authors:[{name:"Michal Nowikowski",title:"Kraken Founder. I\u2019m software engineer focused on full-stack programming and improving software processes.",url:"https://www.linkedin.com/in/godfryd",imageURL:"https://avatars1.githubusercontent.com/u/176567?s=460&u=4ade22771af9569be24b20278d24ef60da6eb0bb&v=4"}],frontMatter:{slug:"autoscaling-with-azure-and-aws-ecs",title:"Autoscaling with Azure and AWS ECS",author:"Michal Nowikowski",author_title:"Kraken Founder. I\u2019m software engineer focused on full-stack programming and improving software processes.",author_url:"https://www.linkedin.com/in/godfryd",author_image_url:"https://avatars1.githubusercontent.com/u/176567?s=460&u=4ade22771af9569be24b20278d24ef60da6eb0bb&v=4",tags:["kraken","cloud"]},unlisted:!1,prevItem:{title:"Webhooks for GitLab and Gitea",permalink:"/blog/webhooks-for-gitlab-and-gitea"},nextItem:{title:"Testing Frameworks",permalink:"/blog/testing-frameworks"}},c={authorsImageUrls:[void 0]},u=[];function l(e){const t={a:"a",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The latest release ",(0,a.jsx)(t.a,{href:"https://github.com/Kraken-CI/kraken/releases/tag/v0.748",children:"0.748 release"}),"\nbrings a new public cloud in autoscaling features: Azure and AWS ECS."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/docs/quick-start",children:"Quick Start"})," guide shows how to install Kraken CI."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/docs/guide-autoscale",children:"Autoscaling Guide"})," shows how to use\nautoscaling with Azure VMs and AWS ECS."]}),"\n",(0,a.jsx)(t.p,{children:"Maintaining a fixed number of machines for Kraken CI can be costly. If\nthere is no high traffic of builds, then some machines sit idle and\nwaste power. The solution to this problem is autoscaling ie. spawning\nmachines with Kraken Agents dynamically depending on the current needs\nin the Kraken CI. If there is submitted a new flow with many building\nor testing jobs, then new machines are spawned. When the flow\ncompletes, machines are terminated and no costs are incurred."}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"/docs/guide-autoscale",children:"Autoscaling Guide"})," shows how to configure\naccess to Azure, then how to configure parameters and behaviour of\nspawned machines. In the end, the usage in job definitions is\npresented."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},4074:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var a=n(4848);const s=e=>{let{img:t}=e;return(0,a.jsx)("a",{href:"/img/"+t,target:"blank",children:(0,a.jsx)("img",{src:"/img/"+t,style:{boxShadow:"0 10px 10px 5px #777",marginBottom:"30px"}})})}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);